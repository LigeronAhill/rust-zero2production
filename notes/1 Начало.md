# Начало

Язык программирования - это нечто большее, чем язык: инструменты являются ключевым элементом опыта использования языка.
То же самое относится и ко многим другим технологиям (например, к `RPC`-фреймворкам, таким как `gRPC` или
`Apache Avro`), и это часто оказывает непропорциональное влияние на внедрение (или упадок) самой технологии. Поэтому к
инструментам следует относиться как к первостепенной задаче как при разработке, так и при обучении самому языку.

Сообщество `Rust` с первых дней своего существования ставит инструментальные средства во главу угла: это видно. Сейчас
мы кратко познакомимся с набором инструментов и утилит, которые будут полезны в нашем путешествии. Некоторые из них
официально поддерживаются организацией `Rust`, другие создаются и обслуживаются сообществом.

## Установка Rust

Существуют различные способы установки `Rust` в вашу систему, но мы остановимся на рекомендуемом способе: через
`rustup`.

Инструкции по установке `rustup` можно найти по адресу [`rustup`](https://rustup.rs).

`rustup` - это нечто большее, чем просто установщик Rust - его основным преимуществом является управление цепочкой
инструментов.

Цепочка инструментов (`toolchain`) - это комбинация цели компиляции и канала выпуска.

### Цели компиляции

Основной целью компилятора `Rust` является преобразование кода `Rust` в машинный код - набор инструкций, которые ваш
процессор и операционная система могут понять и выполнить.

Следовательно, вам нужен разный `бекенд` компилятора `Rust` для каждой цели компиляции, то есть для каждой платформы
(например, 64-разрядной `Linux` или 64-разрядной `OSX`), для которой вы хотите создать работающий исполняемый файл.

Проект `Rust` стремится поддерживать широкий спектр целей компиляции с различным уровнем гарантий. Цели разделены на
уровни, от уровня 1 "гарантированная работа" до уровня 3 "максимальное выполнение".

С исчерпывающим и актуальным списком можно
ознакомиться [здесь](https://doc.rust-lang.org/nightly/rustc/platform-support.html)

### Каналы выпуска

Компилятор `Rust` сам по себе является живым программным обеспечением: он постоянно развивается и совершенствуется
благодаря ежедневному участию сотен добровольцев.

Проект Rust стремится к стабильности без застоя. Цитата из документации `Rust`:

> "... вам никогда не следует бояться перехода на новую стабильную версию `Rust`. Каждое обновление должно быть
> безболезненным, но также должно приносить вам новые функции, уменьшать количество ошибок и ускорять время компиляции."

Вот почему при разработке приложений вам, как правило, следует полагаться на последнюю выпущенную версию компилятора для
запуска, сборки и тестирования вашего программного обеспечения - так называемый `stable channel`.

Новая версия компилятора выходит на `stable channel` каждые шесть недель.

Есть два других канала выпуска:
• `beta`, кандидат на следующий релиз;
• `nightly`, созданный на основе основной ветки rust-lang/rust каждую ночь, отсюда и название.

Тестирование вашего программного обеспечения с помощью `beta` - это один из многих способов поддержки проекта `Rust`,
который помогает выявлять ошибки до даты релиза.

`nightly` служит другой цели: он предоставляет ранним пользователям доступ к незавершенным функциям до их выпуска (или
даже до того, как они будут стабилизированы).

Я бы посоветовал вам дважды подумать, если вы планируете запускать производственное программное обеспечение поверх
компилятора `nightly`: он не просто так называется нестабильным.

### Какие наборы инструментов нам нужны?

Установив `rustup`, вы сразу получите последнюю версию стабильного компилятора с целевой платформой вашего хоста.

Некоторые инструменты, которые мы будем использовать на нашей машине разработки (например, расширение макросов), будут
основаны на компиляторе `nightly`. Несмотря на то, что `nightly` не рекомендуется для производственных нагрузок, нет
ничего страшного, если на нашем локальном компьютере произойдет сбой - мы сможем с этим смириться.

Вы можете установить компилятор nightly, запустив:

```shell
rustup toolchain install nightly --allow-downgrade
```

Некоторые компоненты пакета, установленного `rustup`, могут быть повреждены или отсутствовать в последнем выпуске
`nightly`: `--allow-downgrade` указывает `rustup` найти и установить последнюю версию `nightly`, в которой доступны все
необходимые компоненты.

Вы можете обновить свои наборы инструментов с помощью `rustup update`, а список наборов инструментов `rustup` даст вам
общее представление о том, что установлено в вашей системе.

Нам не потребуется (и мы не будем выполнять) никакой `кросс-компиляции` - наши производственные рабочие нагрузки будут
выполняться в контейнерах, следовательно, нам не нужно выполнять `кросс-компиляцию` с нашей машины разработки на целевой
хост, используемый в нашей производственной среде.

## Настройка проекта

Установка набора инструментов с помощью `rustup` объединяет различные компоненты. Одним из них является сам компилятор
`Rust`, `rustc`. Вы можете ознакомиться с ним с помощью:

```shell
rustc --version
```

Вы не будете тратить много времени на непосредственную работу с `rustc` - вашим основным интерфейсом для создания и
тестирования приложений `Rust` будет `cargo`, инструмент сборки `Rust`.

Вы можете еще раз проверить, все ли работает с помощью:

```shell
cargo --version
```

Давайте используем `cargo` для создания основы проекта, над которым мы будем работать на протяжении всей книги:

```shell
cargo new zero2prod
```

Проект уже представляет собой готовый репозиторий `git`.

Если вы планируете разместить проект на `GitHub`, вам просто нужно создать новый пустой репозиторий и запустить:

```shell
cd zero2prod
git add .
git commit -am "Project skeleton"
git remote add origin git@github.com:YourGitHubNickName/zero2prod.git
git push -u origin main
```

## Continuous Integration

И последнее, на что следует обратить внимание, прежде чем мы перейдем к деталям того, что мы будем создавать: наша
непрерывная интеграция (CI).

При разработке на основе магистрали мы должны иметь возможность развернуть нашу основную ветку в любой момент времени.
Каждый член команды может отделиться от `main`, разработать небольшую функцию или исправить ошибку, вернуться в `main` и
опубликовать ее для наших пользователей.

Непрерывная интеграция позволяет каждому члену команды интегрировать свои изменения в основную ветку по нескольку раз в
день. Это имеет мощный побочный эффект.

Некоторые из них очевидны и их легко обнаружить: это снижает вероятность возникновения запутанных конфликтов при слиянии
из-за долгоживущих ветвей. Никому не нравятся конфликты при слиянии. Некоторые из них более тонкие: непрерывная
интеграция сужает цикл обратной связи. У вас меньше шансов уйти в самостоятельную разработку на несколько дней или
недель только для того, чтобы узнать, что выбранный вами подход не одобрен остальной командой или он плохо интегрируется
с остальным проектом.

Это вынуждает вас вступать в контакт со своими товарищами по команде раньше, чем это будет удобно, корректируя курс при
необходимости, пока это еще легко сделать.

Как нам сделать это возможным?

С набором автоматических проверок, выполняемых при каждой фиксации - нашим конвейером `CI`.

Если одна из проверок завершится неудачей, вы не сможете выполнить слияние с `main` - вот так просто.

Конвейеры `CI` часто выходят за рамки обеспечения работоспособности кода: они являются хорошим местом для выполнения
ряда дополнительных важных проверок - например, сканирования нашего дерева зависимостей на наличие известных
уязвимостей, корректировки, форматирования и т.д.

Мы рассмотрим различные проверки, которые вы, возможно, захотите выполнить в рамках конвейера `CI` ваших проектов
`Rust`, и по ходу дела познакомим вас с соответствующими инструментами. Затем мы предоставим набор готовых конвейеров
`CI` для некоторых крупных поставщиков `CI`.

### Шаги `CI`

#### Тесты

```shell
cargo test
```

#### Покрытие кода

```shell
cargo install cargo-tarpaulin
```

```shell
cargo tarpaulin --ignore-tests
```

#### Качество кода

```shell
rustup component add clippy
```

```shell
cargo clippy -- -D warnings
```

#### Форматирование кода

```shell
rustup component add rustfmt
```

```shell
cargo fmt -- --check
```

#### Уязвимости безопасности

```shell
cargo install cargo-audit
```

```shell
cargo audit
```

### Файлы `github actions`

`audit.yml`

```yml
name: Security audit
on:
  schedule:
    - cron: "0 0 * * *"
  push:
    paths:
      - "**/Cargo.toml"
      - "**/Cargo.lock"
jobs:
  security_audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: taiki-e/install-action@cargo-deny
      - name: Scan for vulnerabilities
        run: cargo deny check advisories
```

`general.yml`

```yml
name: Rust

on: [ push, pull_request ]

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
      - name: Run tests
        run: cargo test

  fmt:
    name: Rustfmt
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt
      - name: Enforce formatting
        run: cargo fmt --check

  clippy:
    name: Clippy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy
      - uses: Swatinem/rust-cache@v2
      - name: Linting
        run: cargo clippy -- -D warnings

  coverage:
    name: Code coverage
    runs-on: ubuntu-latest
    container:
      image: xd009642/tarpaulin
      options: --security-opt seccomp=unconfined
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      - name: Generate code coverage
        run: |
          cargo tarpaulin --verbose --workspace
```

`Makefile.toml`

```toml
[tasks.test]
command = "cargo"
args = ["test", "--all-features"]

[tasks.cover]
install_crate = "cargo-tarpaulin"
command = "cargo"
args = ["tarpaulin", "--ignore-tests"]
dependencies = ["test"]

[tasks.lint]
command = "cargo"
args = ["clippy", "--", "-D", "warnings"]
dependencies = ["cover"]

[tasks.format]
command = "cargo"
args = ["fmt", "--all", "--", "--check"]
dependencies = ["lint"]

[tasks.auditing]
install_crate = "cargo-audit"
command = "cargo"
args = ["audit"]
dependencies = ["format"]

[tasks.ga]
dependencies = ["auditing"]
command = "git"
args = ["add", "."]

[tasks.gc]
dependencies = ["ga"]
command = "git"
args = ["commit", "-m", "${@}"]

[tasks.push]
dependencies = ["gc"]
command = "git"
args = ["push"]
```

```shell
makers push makefile
```